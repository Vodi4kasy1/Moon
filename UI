MoonLight = {}
MoonLight.__index = MoonLight
MoonLight.Notifications = {}

local TweenService = game:GetService("TweenService")
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local HttpService = game:GetService("HttpService")
local UserInputService = game:GetService("UserInputService")

local u2 = UDim2.new
local v3 = Vector3.new
local pi = math.pi

local Blur = Instance.new("BlurEffect")
Blur.Name = "MoonLight_Blur"
Blur.Size = 0
Blur.Parent = game:GetService("Lighting")

function TandemTween(tbl, instances, totaltime)
	local time_per = (totaltime / #tbl)
	for i = 1, #tbl do
		Tween(instances[i], {Position = tbl[i]}, time_per)
		task.wait(time_per)
	end
end

function Tween(inst, tType, t, yield, pref)
	local Tween = TweenService:Create(inst, TweenInfo.new(pref or t or 0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), tType)
	Tween:Play()
	if yield then
		Tween.Completed:Wait()
	end
end

function RoundNumber(num, numDecimalPlaces)
	return tonumber(string.format("%." .. (numDecimalPlaces or 0) .. "f", num))
end

function Ripple(asset, x, y)
	assert(x and y, "Please provide x and y coordinates!")
	coroutine.resume(coroutine.create(function()
		local New_Ripple = GetAsset("RippleAsset"):Clone()
		New_Ripple.Parent = asset
		New_Ripple.ImageTransparency = 0.6
		New_Ripple.Position = u2(0, (x - asset.AbsolutePosition.X), 0, (y - asset.AbsolutePosition.Y - 36))
		New_Ripple.Size = u2(0, 0, 0, 0)
		local Length, Size = 0.6, math.max(asset.AbsoluteSize.X, asset.AbsoluteSize.Y) * 1.5
		local Tween = TweenService:Create(New_Ripple, TweenInfo.new(Length, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
			Size = u2(0, Size, 0, Size),
			Position = u2(0.5, -Size / 2, 0.5, -Size / 2),
			ImageTransparency = 1
		})
		Tween:Play()
		Tween.Completed:Wait()
		New_Ripple:Destroy()
	end))
end

function GetAsset(Asset)
	for _, v in pairs(game.CoreGui:FindFirstChild("MoonLightUI"):GetDescendants()) do
		if v.Name == Asset then
			return v
		end
	end
end

function MoonLight.UI(Name)
	if game.CoreGui:FindFirstChild("MoonLightUI") then
		game.CoreGui.MoonLightUI:Destroy()
		game:GetService("Lighting"):FindFirstChild("MoonLight_Blur"):Destroy()
	end

	local Library = {
		_UI = game:GetObjects("rbxassetid://1234567890")[1], -- Replace with actual asset ID
		Name = Name or "MoonLight",
		Tabs = {},
		State = false,
		ToggleKey = Enum.KeyCode.RightControl,
		Debounce = false,

		Show_UI = function(self)
			Tween(self._UI.MainFrame, {Position = u2(0.5, 0, 0.5, 0), Transparency = 0}, 0.5)
		end,

		Hide_UI = function(self)
			Tween(self._UI.MainFrame, {Position = u2(1.5, 0, 0.5, 0), Transparency = 1}, 0.5)
		end,

		Hide_All = function(self)
			for _, v in pairs(self._UI.MainFrame.Holder:GetChildren()) do
				if v.ClassName ~= "UIListLayout" and v.ClassName ~= "Folder" then
					v.Visible = false
				end
			end
		end,

		Show = function(self, show_tbl)
			for _, v in pairs(show_tbl) do
				v.Visible = true
			end
		end,

		Hide = function(self, hide_tbl)
			for _, v in pairs(hide_tbl) do
				v.Visible = false
			end
		end,

		Startup = function(self)
			local TUI = self._UI
			local Widgets = TUI.Widgets
			local Widget1, Widget2, Widget3 = Widgets.PlayerInfo, Widgets.Settings, Widgets.Music
			local Tabs = TUI.TabContainer
			local BottomMenu = TUI.BottomMenu
			local TopBar = TUI.TopBar
			local TimeDisplay = TUI.TimeDisplay

			local TabsPos = Tabs.Position
			local BMPos = BottomMenu.Position
			local TopPos = TopBar.Position
			local TimePos = TimeDisplay.Position
			local Widgets = {Widget1, Widget2, Widget3}
			local WidgetPos = {Widget1.Position, Widget2.Position, Widget3.Position}

			for i, v in pairs(Widgets) do
				v.Position = u2(v.Position.X.Scale, v.Position.X.Offset, 1.2, v.Position.Y.Offset)
			end
			Tabs.Position = u2(-0.1, Tabs.Position.X.Offset, Tabs.Position.Y.Scale, Tabs.Position.Y.Offset)
			BottomMenu.Position = u2(BottomMenu.Position.X.Scale, BottomMenu.Position.X.Offset, 1.2, BottomMenu.Position.Y.Offset)
			TopBar.Position = u2(TopBar.Position.X.Scale, TopBar.Position.X.Offset, -0.2, TopBar.Position.Y.Offset)
			TimeDisplay.TextTransparency = 1
			TUI.Darkener.BackgroundTransparency = 1

			for _, v in pairs(TUI:GetChildren()) do
				if v.ClassName ~= "Folder" and v.Name ~= "Darkener" and v.Name ~= "MusicPlayer" then
					v.Visible = true
				end
			end

			for _, v in pairs(TUI.Widgets:GetChildren()) do
				v.Visible = true
			end

			game:GetService("StarterGui"):SetCoreGuiEnabled(Enum.CoreGuiType.All, false)

			Tween(TUI.Darkener, {BackgroundTransparency = 0.3}, 0.5, true)
			TandemTween(WidgetPos, Widgets, 0.5)
			Tween(BottomMenu, {Position = BMPos}, 0.25)
			Tween(Tabs, {Position = TabsPos}, 0.25)
			Tween(TopBar, {Position = TopPos}, 0.25)
			Tween(TimeDisplay, {TextTransparency = 0}, 0.25, true)
		end,

		Update = function(self)
			if self.Debounce then return end
			self.Debounce = true
			if self.State then
				Tween(Blur, {Size = 20}, 0.5)
				self._UI.Enabled = true
				self:Startup()
			else
				self._UI.Enabled = false
				Tween(Blur, {Size = 0}, 0.5, true)
				game:GetService("StarterGui"):SetCoreGuiEnabled(Enum.CoreGuiType.All, true)
			end
			self.Debounce = false
		end
	}

	Library._UI.Parent = game.CoreGui
	Library._UI.Enabled = false
	Library._UI:FindFirstChild("Name").Text = Library.Name
	Library._UI.IgnoreGuiInset = true

	Library._UI.MainFrame.CloseButton.MouseButton1Down:Connect(function()
		Library.State = false
		Library:Update()
	end)

	local TopBar = Library._UI.TopBar
	local ConfigData
	local success = pcall(function()
		ConfigData = HttpService:JSONDecode(readfile("ml_config.json"))
	end)

	function SaveConfig()
		writefile("ml_config.json", HttpService:JSONEncode(ConfigData))
	end

	if not success then
		ConfigData = {
			LastVisit = os.date("%x", os.time()),
			Username = "MoonLightUser"
		}
		SaveConfig()
	end

	TopBar.LastVisit.Text = "Last Visit: " .. ConfigData.LastVisit
	TopBar.Creator.Text = "Creator: " .. ConfigData.Username
	TopBar.User.Text = "Welcome, " .. Players.LocalPlayer.Name

	ConfigData.LastVisit = os.date("%x", os.time())
	SaveConfig()

	local MusicWidget = Library._UI.Widgets.Music
	local MusicPlayer = Library._UI.MusicPlayer

	MusicWidget.ConnectButton.MouseButton1Click:Connect(function()
		Tween(MusicWidget.ConnectButton, {ImageTransparency = 1}, 0.3)
		Tween(MusicWidget.Under, {TextTransparency = 1}, 0.3)
		task.wait(0.5)

		local TokenData
		local success = pcall(function()
			TokenData = readfile("ml_music_token.txt")
		end)

		if not success then
			local prompt = "Enter your music service token"
			for i = 0, #prompt do
				MusicWidget.Under.Text = string.sub(prompt, 0, i)
				task.wait(0.05)
			end
			Tween(MusicWidget.TokenInput, {Position = u2(0.5, 0, 0.8, 0)}, 0.5)

			local Focus
			Focus = MusicWidget.TokenInput.FocusLost:Connect(function()
				if MusicWidget.TokenInput.Text ~= "" then
					Focus:Disconnect()
					writefile("ml_music_token.txt", MusicWidget.TokenInput.Text)
					TokenData = MusicWidget.TokenInput.Text
					Tween(MusicWidget.TokenInput, {Position = u2(0.5, 0, 1.5, 0)}, 0.5)
				end
			end)
		end

		repeat task.wait() until TokenData
		local message = "Connected!"
		for i = 0, #message do
			MusicWidget.Under.Text = string.sub(message, 0, i)
			task.wait(0.05)
		end

		Tween(MusicWidget.Previous, {ImageTransparency = 0}, 0.3)
		Tween(MusicWidget.Next, {ImageTransparency = 0}, 0.3)
		Tween(MusicWidget.PlayPause, {ImageTransparency = 0}, 0.3)
		MusicPlayer.Visible = true
	end)

	UserInputService.InputBegan:Connect(function(Key, IsTyping)
		if IsTyping then return end
		if Key.KeyCode == Library.ToggleKey then
			Library.State = not Library.State
			Library:Update()
		end
	end)

	return setmetatable(Library, MoonLight)
end

function MoonLight:Tab(Name, Icon)
	local Tab = {
		Name = Name,
		Icon = "rbxassetid://" .. (Icon or "6034830835"),
		Containers = {},
		Tweens = {},
		Tab = GetAsset("TabTemplate"):Clone(),
		_UI = self._UI,

		CancelTweens = function(self)
			for i, tween in pairs(self.Tweens) do
				tween:Cancel()
				table.remove(self.Tweens, i)
			end
		end,

		Update = function(self)
			self.Tab.Icon.Image = self.Icon
			self.Tab.Label.Text = self.Name
			local count = #self._UI.Tabs
			self._UI.TabContainer.Size = u2(0, 80, 0, 60 + (50 * count))
		end
	}

	table.insert(self.Tabs, Tab)
	Tab.Tab.Parent = self._UI.TabContainer.Holder
	Tab:Update()

	Tab.Tab.MouseEnter:Connect(function()
		Tab:CancelTweens()
		local Tween = TweenService:Create(Tab.Tab.Label, TweenInfo.new(0.2), {TextTransparency = 0})
		Tween:Play()
		table.insert(Tab.Tweens, Tween)
	end)

	Tab.Tab.MouseLeave:Connect(function()
		Tab:CancelTweens()
		local Tween = TweenService:Create(Tab.Tab.Label, TweenInfo.new(0.2), {TextTransparency = 0.5})
		Tween:Play()
		table.insert(Tab.Tweens, Tween)
	end)

	Tab.Tab.MouseButton1Down:Connect(function()
		self:Hide_All()
		self:Show(Tab.Containers)
		Tween(self._UI.MainFrame, {Position = u2(0.5, 0, 0.5, 0)}, 0.5)
	end)

	self._UI.MainFrame.Holder.UIListLayout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
		self._UI.MainFrame.Holder.CanvasSize = u2(0, 0, 0, self._UI.MainFrame.Holder.UIListLayout.AbsoluteContentSize.Y)
	end)

	return setmetatable(Tab, MoonLight)
end

function MoonLight:Container(Name)
	local Container = {
		Name = Name,
		Assets = {},
		Drops = {},
		Tweens = {},
		State = false,
		Container = GetAsset("Container"):Clone(),

		CancelTweens = function(self)
			for i, tween in pairs(self.Tweens) do
				tween:Cancel()
				table.remove(self.Tweens, i)
			end
		end,

		Update = function(self)
			self.Container.Title.Text = self.Name
		end,

		Expand = function(self)
			self:CancelTweens()
			Tween(self.Container.Arrow, {Rotation = 90}, 0.3)
			local Tween = TweenService:Create(self.Container, TweenInfo.new(0.3), {Size = u2(0, 450, 0, 60)})
			Tween:Play()
			table.insert(self.Tweens, Tween)
		end,

		Collapse = function(self)
			self:CancelTweens()
			Tween(self.Container.Arrow, {Rotation = 0}, 0.3)
			local Tween = TweenService:Create(self.Container, TweenInfo.new(0.3), {Size = u2(0, 450, 0, 60 + 50 * #self.Assets)})
			Tween:Play()
			table.insert(self.Tweens, Tween)
		end
	}

	table.insert(self.Containers, Container)
	Container.Container.Parent = self._UI.MainFrame.Holder
	Container:Update()

	Container.Container.Arrow.MouseButton1Down:Connect(function()
		Container.State = not Container.State
		if Container.State then
			Container:Collapse()
			for _, drop in pairs(Container.Drops) do
				if not drop.State then
					Tween(drop.Asset, {Size = u2(0, 435, 0, 60)}, 0.1)
					Tween(drop.Asset.Arrow, {Rotation = 0}, 0.1)
				end
			end
		else
			Container:Expand()
		end
	end)

	return setmetatable(Container, MoonLight)
end

function MoonLight:Button(Name, Callback)
	local Button = {
		Name = Name,
		Callback = Callback or function() end,
		Class = "Button",
		Asset = GetAsset("Button"):Clone(),

		Update = function(self)
			self.Asset.TextLabel.Text = self.Name
		end
	}

	table.insert(self.Assets, Button)
	Button.Asset.Visible = true
	Button.Asset.Parent = self.Container.ScrollingFrame
	Button:Update()

	Button.Asset.MouseButton1Down:Connect(function(x, y)
		pcall(Button.Callback)
		Ripple(Button.Asset, x, y)
	end)

	return setmetatable(Button, MoonLight)
end

function MoonLight:Toggle(Name, StartingState, Callback, RunOnStart)
	local Toggle = {
		Name = Name,
		State = StartingState or false,
		Callback = Callback or function() end,
		Class = "Toggle",
		Asset = GetAsset("Toggle"):Clone(),

		Update = function(self)
			self.Asset.TextLabel.Text = self.Name
			self.Asset.Indicator.Image = self.State and "rbxassetid://6031068426" or "rbxassetid://6031068433"
		end
	}

	table.insert(self.Assets, Toggle)
	Toggle.Asset.Visible = true
	Toggle.Asset.Parent = self.Container.ScrollingFrame
	Toggle:Update()

	Toggle.Asset.MouseButton1Down:Connect(function(x, y)
		Toggle.State = not Toggle.State
		Toggle:Update()
		pcall(Toggle.Callback, Toggle.State)
		Ripple(Toggle.Asset, x, y)
	end)

	if Toggle.State and RunOnStart then
		pcall(Toggle.Callback, Toggle.State)
	end

	return setmetatable(Toggle, MoonLight)
end

function MoonLight:Dropdown(Name, List, Callback)
	local Dropdown = {
		Name = Name,
		List = List or {},
		Callback = Callback or function() end,
		State = false,
		Debounce = false,
		Class = "Dropdown",
		Asset = GetAsset("Dropdown"):Clone(),

		Other = {ExtensionSize = nil},

		Update = function(self)
			self.Asset.Title.Text = self.Name
			self.Other.ExtensionSize = math.min(70 + 45 * #self.List, 400)

			for _, v in pairs(self.Asset.DropContainer:GetChildren()) do
				if v:IsA("TextButton") then
					v:Destroy()
				end
			end

			local Template = GetAsset("DropdownItem")
			for i, v in pairs(self.List) do
				local Item = Template:Clone()
				Item.Parent = self.Asset.DropContainer
				Item.Visible = true
				Item.Text = v
				Item.Name = v
				Item.MouseButton1Down:Connect(function()
					if not self.State then
						pcall(self.Callback, v)
						self.State = not self.State
						Tween(self.Asset, {Size = u2(0, 435, 0, 60)}, 0.35)
						Tween(self.Asset.Arrow, {Rotation = 0}, 0.35)
						Tween(self.Container, {Size = u2(self.Container.Size.X.Scale, self.Container.Size.X.Offset, self.Container.Size.Y.Scale, self.Container.Size.Y.Offset - (self.Other.ExtensionSize - 60))}, 0.35)
						self.Debounce = false
					end
				end)
			end

			self.Asset.DropContainer.CanvasSize = #self.List > 6 and u2(0, 0, 0, self.Asset.DropContainer.UIListLayout.AbsoluteContentSize.Y + 70) or u2(0, 0, 0, 0)
		end
	}

	table.insert(self.Assets, Dropdown)
	table.insert(self.Drops, Dropdown)
	Dropdown.Asset.Visible = true
	Dropdown.Asset.Parent = self.Container.ScrollingFrame
	Dropdown:Update()

	Dropdown.Asset.MouseButton1Down:Connect(function(x, y)
		if Dropdown.Debounce then return end
		Ripple(Dropdown.Asset, x, y)
		Dropdown.Debounce = true
		Dropdown.State = not Dropdown.State
		if Dropdown.State then
			Tween(Dropdown.Asset, {Size = u2(0, 435, 0, Dropdown.Other.ExtensionSize)}, 0.35)
			Tween(Dropdown.Asset.Arrow, {Rotation = 180}, 0.35)
			Tween(self.Container, {Size = u2(self.Container.Size.X.Scale, self.Container.Size.X.Offset, self.Container.Size.Y.Scale, self.Container.Size.Y.Offset + (Dropdown.Other.ExtensionSize - 60))}, 0.35)
		else
			Tween(Dropdown.Asset, {Size = u2(0, 435, 0, 60)}, 0.35)
			Tween(Dropdown.Asset.Arrow, {Rotation = 0}, 0.35)
			Tween(self.Container, {Size = u2(self.Container.Size.X.Scale, self.Container.Size.X.Offset, self.Container.Size.Y.Scale, self.Container.Size.Y.Offset - (Dropdown.Other.ExtensionSize - 60))}, 0.35)
		end
		task.wait(0.35)
		Dropdown.Debounce = false
	end)

	return setmetatable(Dropdown, MoonLight)
end

function MoonLight:Label(Text)
	local Label = {
		Text = Text,
		Class = "Label",
		Asset = GetAsset("Label"):Clone(),

		Update = function(self)
			self.Asset.TextLabel.Text = self.Text
		end
	}

	table.insert(self.Assets, Label)
	Label.Asset.Visible = true
	Label.Asset.Parent = self.Container.ScrollingFrame
	Label:Update()

	return setmetatable(Label, MoonLight)
end

function MoonLight:Keybind(Name, StartingKey, BlacklistedKeys, Callback)
	local Keybind = {
		Name = Name,
		Key = StartingKey or Enum.KeyCode.E,
		Blacklist = BlacklistedKeys or {"W", "A", "S", "D"},
		Callback = Callback or function() end,
		Debounce = false,
		Class = "Keybind",
		Asset = GetAsset("Keybind"):Clone(),
		Connections = {InChange = false},

		ValidKey = function(self, Key)
			return typeof(Key) == "EnumItem"
		end,

		GetKeystring = function(self, Key)
			if Key == "..." then return "..." end
			return string.sub(tostring(Key), 14)
		end,

		IsNotMouse = function(self, Key)
			return not (Key.UserInputType == Enum.UserInputType.MouseButton1 or Key.UserInputType == Enum.UserInputType.MouseButton2)
		end,

		Update = function(self)
			self.Asset.TextLabel.Text = self.Name
			self.Asset.KeyLabel.Text = self:GetKeystring(self.Key)
		end
	}

	table.insert(self.Assets, Keybind)
	Keybind.Asset.Visible = true
	Keybind.Asset.Parent = self.Container.ScrollingFrame
	Keybind:Update()

	Keybind.Connections.KeyPress = UserInputService.InputBegan:Connect(function(Input, GameProcessed)
		if GameProcessed or Keybind.Connections.InChange then return end
		if Input.KeyCode == Keybind.Key then
			pcall(Keybind.Callback)
		end
	end)

	Keybind.Asset.MouseButton1Down:Connect(function(x, y)
		if Keybind.Debounce then return end
		Keybind.Debounce = true
		Keybind.Connections.InChange = true
		Ripple(Keybind.Asset, x, y)

		local Continue = false
		local Cache = {OldText = Keybind.Name, OldKey = Keybind.Key}
		Keybind.Name = Keybind.Name .. " [Enter to cancel]"
		Keybind.Key = "..."
		Keybind:Update()

		Keybind.Connections.Change = UserInputService.InputBegan:Connect(function(Input, GameProcessed)
			if GameProcessed or Keybind:IsNotMouse(Input) then return end
			if Input.KeyCode == Enum.KeyCode.Return then
				Continue = true
				Keybind.Key = Cache.OldKey
				Keybind.Connections.Change:Disconnect()
				Keybind:Update()
			elseif not table.find(Keybind.Blacklist, Keybind:GetKeystring(Input.KeyCode)) then
				Keybind.Key = Input.KeyCode
				Keybind:Update()
				Continue = true
				pcall(Keybind.Callback, Keybind:GetKeystring(Keybind.Key))
				Keybind.Connections.Change:Disconnect()
			end
		end)

		repeat task.wait() until Continue
		Keybind.Name = Cache.OldText
		Keybind.Connections.InChange = false
		Keybind:Update()
		task.wait(0.5)
		Keybind.Debounce = false
	end)

	return setmetatable(Keybind, MoonLight)
end

function MoonLight:TextBox(Name, Callback)
	local TextBox = {
		Name = Name,
		Callback = Callback or function() end,
		CanCall = true,
		Class = "TextBox",
		Asset = GetAsset("TextBox"):Clone(),

		Update = function(self, text)
			self.Asset.TextLabel.Text = self.Name
			if text then
				self.Asset.Input.Text = text
				pcall(self.Callback, text)
			end
		end
	}

	table.insert(self.Assets, TextBox)
	TextBox.Asset.Visible = true
	TextBox.Asset.Parent = self.Container.ScrollingFrame
	TextBox:Update()

	TextBox.Asset.Input.Focused:Connect(function()
		if TextBox.CanCall then
			TextBox.Asset.Input:ReleaseFocus()
		end
	end)

	TextBox.Asset.MouseButton1Down:Connect(function(x, y)
		if not TextBox.CanCall then return end
		TextBox.CanCall = false
		Ripple(TextBox.Asset, x, y)
		TextBox.Asset.Input:CaptureFocus()
		TextBox.Asset.Input.FocusLost:Wait()
		pcall(TextBox.Callback, TextBox.Asset.Input.Text)
		task.wait(0.2)
		TextBox.CanCall = true
	end)

	return setmetatable(TextBox, MoonLight)
end

function MoonLight:Slider(Name, Min, Max, Start, Callback, UseDecimals)
	local Slider = {
		Name = Name,
		Min = Min or 0,
		Max = Max or 100,
		Value = Start or 0,
		Callback = Callback or function() end,
		Class = "Slider",
		Dragging = false,
		Asset = GetAsset("Slider"):Clone(),

		Update = function(self)
			self.Asset.Title.Text = self.Name
			local New = self.Value
			Tween(self.Asset.SliderBar.Fill, {Size = u2((New - self.Min) / (self.Max - self.Min), 0, 1, 0)}, 0.1)
			self.Asset.Value.Text = tostring(UseDecimals and RoundNumber(New, 1) or math.floor(New))
		end
	}

	table.insert(self.Assets, Slider)
	Slider.Asset.Visible = true
	Slider.Asset.Parent = self.Container.ScrollingFrame
	Slider:Update()

	Slider.Asset.SliderBar.Handle.InputBegan:Connect(function(Input)
		if Input.UserInputType == Enum.UserInputType.MouseButton1 then
			Slider.Dragging = true
		end
	end)

	Slider.Asset.SliderBar.Handle.InputEnded:Connect(function(Input)
		if Input.UserInputType == Enum.UserInputType.MouseButton1 then
			Slider.Dragging = false
		end
	end)

	UserInputService.InputChanged:Connect(function(Input)
		if Slider.Dragging and Input.UserInputType == Enum.UserInputType.MouseMovement then
			local Bound = Slider.Asset.SliderBar.AbsoluteSize.X
			local Pos = math.clamp((Input.Position.X - Slider.Asset.SliderBar.AbsolutePosition.X) / Bound, 0, 1)
			Tween(Slider.Asset.SliderBar.Fill, {Size = u2(Pos, 0, 1, 0)}, 0.1)
			Slider.Value = UseDecimals and RoundNumber((Pos * (Slider.Max - Slider.Min) + Slider.Min), 1) or math.floor(Pos * (Slider.Max - Slider.Min) + Slider.Min)
			Slider.Asset.Value.Text = tostring(Slider.Value)
			pcall(Slider.Callback, Slider.Value)
		end
	end)

	return setmetatable(Slider, MoonLight)
end

function MoonLight:Notification(Title, Info, Icon, Duration)
	if #MoonLight.Notifications >= 5 then return end
	local Notification = {
		Title = Title or "Notification",
		Info = Info or "No info provided",
		Icon = Icon and "rbxassetid://" .. Icon or "rbxassetid://6031071053",
		Data = {
			Queue = #MoonLight.Notifications + 1,
			Notification = GetAsset("Notification"):Clone(),
			TOC = tick(),
			Last = Duration or 3
		}
	}

	Notification.Data.Notification.Name = Notification.Data.Queue
	Notification.Data.Notification.Title.Text = Notification.Title
	Notification.Data.Notification.Info.Text = Notification.Info
	Notification.Data.Notification.Icon.Image = Notification.Icon
	Notification.Data.Notification.Parent = GetAsset("Notifications")
	table.insert(MoonLight.Notifications, Notification)
	MoonLight:UpdateNotifications()

	return Notification
end

function MoonLight:UpdateNotifications()
	for i, v in pairs(MoonLight.Notifications) do
		if (tick() - v.Data.TOC) >= v.Data.Last then
			Tween(v.Data.Notification, {Position = u2(1, 0, v.Data.Notification.Position.Y.Scale, 0)}, 0.5)
			task.delay(0.5, function()
				v.Data.Notification:Destroy()
			end)
			table.remove(MoonLight.Notifications, i)
		end
	end

	if #MoonLight.Notifications > 1 then
		table.sort(MoonLight.Notifications, function(a, b)
			return a.Data.Queue < b.Data.Queue
		end)
	end

	for i, v in ipairs(MoonLight.Notifications) do
		local Move_Axis = 0.85 - (0.1 * (i - 1))
		if v.Data.Notification.Position.X.Scale == 1 then
			v.Data.Notification.Position = u2(1, 0, Move_Axis, 0)
			Tween(v.Data.Notification, {Position = u2(0.8, 0, Move_Axis, 0)}, 0.5)
		else
			Tween(v.Data.Notification, {Position = u2(0.8, 0, Move_Axis, 0)}, 0.5)
		end
	end
end

function MoonLight:SetToggleKey(Key)
	self.ToggleKey = Key
end

return MoonLight
